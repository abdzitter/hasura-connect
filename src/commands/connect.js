const { Command, flags } = require('@oclif/command')
var mqtt = require('mqtt')
var fs = require('fs')
var btoa = require('btoa')
var fetch = require('node-fetch')
const { encode } = require('punycode')
var sparkplug = require('sparkplug-payload').get('spBv1.0')

let debug = true
let parse = console.log

class ConnectCommand extends Command {
	async run() {
		const { flags } = this.parse(ConnectCommand)
		if (flags.debug) debug = true
		this.loadConfig(this.subScribeMQTT)
	}
	async loadConfig(subscribe) {
		fs.readFile('config.json', 'utf8', function (err, data) {
			if (err) throw err
			fs.readFile('parse.js', 'utf8', async function (e, d) {
				if (e) throw e
				// console.log(d)
				const config = JSON.parse(data)
				if (!config.HASURA_HOST || !config.MQTT_HOST)
					throw 'Invalid configuration file detected'

				async function setupParser() {
					// var moduleData ="export function hello() { console.log('hello'); };"
					var b64moduleData = 'data:text/javascript;base64,' + btoa(d)
					const module = await import(b64moduleData)
					parse = module.getMutation
					// const resp = module.getMutation({}, 'test/javascript')
					// console.log(JSON.stringify(resp, null, 2))

					subscribe(config)
				}
				await setupParser()
			})
		})
	}
	async subScribeMQTT({
		HASURA_HOST,
		MQTT_HOST,
		MODE,
		MQTT_CHANNEL = 'spBv1.0/#',
	}) {
		var client = mqtt.connect(MQTT_HOST)
		client.on('error', function (err) {
			if (err) throw err
		})
		client.on('connect', function () {
			debug && debug && console.log('CONNECTED')
			client.subscribe(MQTT_CHANNEL, function (err) {
				if (!err) {
					console.log('Connected & subscibed to MQTT broker')
					debug && console.log(`SUBSCRIBED TO ${MQTT_CHANNEL}`)
					//       client.publish("spBv1.0/test", "Hello mqtt"); // test publish
				}
			})
		})

		client.on('message', function (topic, message) {
			// message is Buffer
			debug && console.log(topic)
			const decoded = decode(message, topic, MODE)

			debug && console.log('_DECODED', decoded)
			sendToHasura(decoded, HASURA_HOST)
		})
	}
}
function sendToHasura(body, HASURA_HOST) {
	debug && console.log(JSON.stringify(body, null, 2))
	return fetch(`${HASURA_HOST}/v1/graphql`, {
		headers: {
			accept: '*/*',
			'accept-language': 'en-US,en;q=0.9,ml;q=0.8',
			'content-type': 'application/json',
			...(body.headers || {}),
		},
		method: 'POST',
		body:JSON.stringify(body),
	})
		.then((res) => res.json())
		.then((resp) => debug && console.log(JSON.stringify(resp, null, 2)))
}

function decode(encoded, topic, MODE) {
	if (MODE === 'spBv1.0') return sparkplug.decodePayload(encoded)
	if (parse) return parse(encoded.toString(), topic)
	return encoded
}

ConnectCommand.description = `Connect to the MQTT broker
...
This will start an MQTT client and start subscribing to the topic specified in the config.json. every message payload that is recieved will be parsed using getMutation method.
getMutation method will be invoked with message and topic and the graphQL query generated by the method used to hit hasura instance.
"hasura-connect connect"  can be executed parallelly just like any nodeJS application.
`

ConnectCommand.flags = {
	// name: flags.string({ char: 'n', description: 'name to print' }),
	debug: flags.boolean({
		char: 'd',
		description: 'pass true to enable debugging ',
	}),
}

module.exports = ConnectCommand
