const { Command, flags } = require('@oclif/command')
var mqtt = require('mqtt')
var fs = require('fs')
var btoa = require('btoa')
var fetch = require('node-fetch')
const { encode } = require('punycode')
var sparkplug = require('sparkplug-payload').get('spBv1.0')

let debug = false
let parse = console.log
let log;
let count=0;
let errorCount=0;
class ConnectCommand extends Command {
	async catch(error) {
		// do something or
		// re-throw to be handled globally
		console.log("Stoping execution")
		console.log(count+" mutations successful")
		console.log(errorCount + ' mutations failed')
		throw error;
	  }
	async run() {
		const { flags } = this.parse(ConnectCommand)
		if (flags.debug) debug = true
		log = this.log
		this.loadConfig(this.subScribeMQTT)
	}
	async loadConfig(subscribe) {
		fs.readFile('config.json', 'utf8', function (err, data) {
			if (err) throw err
			fs.readFile('parse.js', 'utf8', async function (e, d) {
				if (e) throw e
				// log(d)
				const config = JSON.parse(data)
				if (!config.HASURA_HOST || !config.MQTT_HOST)
					throw 'Invalid configuration file detected'

				async function setupParser() {
					// var moduleData ="export function hello() { log('hello'); };"
					var b64moduleData = 'data:text/javascript;base64,' + btoa(d)
					const module = await import(b64moduleData)
					parse = module.getMutation
					// const resp = module.getMutation({}, 'test/javascript')
					// log(JSON.stringify(resp, null, 2))

					subscribe(config)
				}
				await setupParser()
			})
		})
	}
	async subScribeMQTT({
		HASURA_HOST,
		MQTT_HOST,
		MODE,
		MQTT_CHANNEL = 'spBv1.0/#',
	}) {
		var client = mqtt.connect(MQTT_HOST)
		client.on('error', function (err) {
			if (err) throw err
		})
		client.on('connect', function () {
			debug && debug && log('CONNECTED')
			client.subscribe(MQTT_CHANNEL, function (err) {
				if (!err) {
					log('Connected & subscibed to MQTT broker')
					debug && log(`SUBSCRIBED TO ${MQTT_CHANNEL}`)
					//       client.publish("spBv1.0/test", "Hello mqtt"); // test publish
				}
			})
		})

		client.on('message', function (topic, message) {
			// message is Buffer
			debug && log(topic)
			const decoded = decode(message, topic, MODE)

			debug && log('_DECODED', decoded)
			sendToHasura(decoded, HASURA_HOST)
		})
	}
}
function sendToHasura(body, HASURA_HOST) {
	debug && log(JSON.stringify(body, null, 2))
	return fetch(`${HASURA_HOST}/v1/graphql`, {
		headers: {
			accept: '*/*',
			'accept-language': 'en-US,en;q=0.9,ml;q=0.8',
			'content-type': 'application/json',
			...(body.headers || {}),
		},
		method: 'POST',
		body:JSON.stringify(body),
	})
		.then((res) => {
			count++;
			log(count+" mutations executed successfully")
			return res.json()
		})
		.then((resp) => debug && log(JSON.stringify(resp, null, 2)))
}

function decode(encoded, topic, MODE) {
	if (MODE === 'spBv1.0'&&parse) {
		return parse(sparkplug.decodePayload(encoded), topic)
	}
	if (parse) return parse(encoded.toString(), topic)
	return encoded
}

ConnectCommand.description = `Connect to the MQTT broker
...
This will start an MQTT client and start subscribing to the topic specified in the config.json. every message payload that is recieved will be parsed using getMutation method.
getMutation method will be invoked with message and topic and the graphQL query generated by the method used to hit hasura instance.

"hasura-connect connect" will use the configuration from config.json by default, also it use getMutation method from the parse.js to convert the payloads into necessary mutations. 
considering the stateless behaviour of the runtime this can be executed parallelly in multiple instances, you may also use process managers like pm2 to manage multiple process in the same machine.
`

ConnectCommand.flags = {
	// name: flags.string({ char: 'n', description: 'name to print' }),
	debug: flags.boolean({
		char: 'd',
		description: 'pass true to enable debugging ',
	}),
}

module.exports = ConnectCommand
